Fixes picked from commits 3ad0050469e6ea63b4081f2a88c264ce8ab55c51 and
2fb00c8a16ce93756cddd70536e361a49369ba88

diff --git a/src/error.cpp b/src/error.cpp
index 6ce0fb6..46ac75d 100644
--- a/src/error.cpp
+++ b/src/error.cpp
@@ -106,6 +106,7 @@ namespace {
         { 52, N_("%1 has invalid XMP value type `%2'") }, // %1=key, %2=value type
         { 53, N_("Not a valid ICC Profile") },
         { 54, N_("Not valid XMP") },
+        { 58, N_("corrupted image metadata") },
     };
 
 }
diff --git a/src/pngchunk.cpp b/src/pngchunk.cpp
index 68f05d1..0c4f9b6 100644
--- a/src/pngchunk.cpp
+++ b/src/pngchunk.cpp
@@ -46,6 +46,7 @@ EXIV2_RCSID("@(#) $Id: pngchunk.cpp 4719 2017-03-08 20:42:28Z robinwmills $")
 #include <iostream>
 #include <cassert>
 #include <cstdio>
+#include <algorithm>
 
 #include <zlib.h>     // To uncompress or compress text chunk
 
@@ -162,12 +163,25 @@ namespace Exiv2 {
         }
         else if(type == iTXt_Chunk)
         {
+            const int nullSeparators = std::count(&data.pData_[keysize+3], &data.pData_[data.size_-1], '\0');
+            if (nullSeparators < 2) throw Error(58, "iTXt chunk: not enough null separators");
+
             // Extract a deflate compressed or uncompressed UTF-8 text chunk
 
             // we get the compression flag after the key
-            const byte* compressionFlag   = data.pData_ + keysize + 1;
+            const byte compressionFlag   = data.pData_[keysize + 1];
             // we get the compression method after the compression flag
-            const byte* compressionMethod = data.pData_ + keysize + 2;
+            const byte compressionMethod = data.pData_[keysize + 2];
+
+            if (compressionFlag != 0x00 && compressionFlag != 0x01)
+            {
+                    throw Error(58, "iTXt chunk: not valid value in compressionFlag");
+            }
+            if (compressionMethod != 0x00)
+            {
+                    throw Error(58, "iTXt chunk: not valid value in compressionMethod");
+            }
+
             // language description string after the compression technique spec
             std::string languageText((const char*)(data.pData_ + keysize + 3));
             unsigned int languageTextSize = static_cast<unsigned int>(languageText.size());
@@ -175,7 +189,7 @@ namespace Exiv2 {
             std::string translatedKeyText((const char*)(data.pData_ + keysize + 3 + languageTextSize +1));
             unsigned int translatedKeyTextSize = static_cast<unsigned int>(translatedKeyText.size());
 
-            if ( compressionFlag[0] == 0x00 )
+            if ( compressionFlag == 0x00 )
             {
                 // then it's an uncompressed iTXt chunk
 #ifdef DEBUG
@@ -189,7 +203,7 @@ namespace Exiv2 {
                 arr.alloc(textsize);
                 arr = DataBuf(text, textsize);
             }
-            else if ( compressionFlag[0] == 0x01 && compressionMethod[0] == 0x00 )
+            else if ( compressionFlag == 0x01 && compressionMethod == 0x00 )
             {
                 // then it's a zlib compressed iTXt chunk
 #ifdef DEBUG
-- 
2.19.0

